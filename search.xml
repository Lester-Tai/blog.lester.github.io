<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring事务捕获异常依旧回滚</title>
      <link href="/blogs/2021/01/25/Spring%E4%BA%8B%E5%8A%A1%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E4%BE%9D%E6%97%A7%E5%9B%9E%E6%BB%9A/"/>
      <url>/blogs/2021/01/25/Spring%E4%BA%8B%E5%8A%A1%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E4%BE%9D%E6%97%A7%E5%9B%9E%E6%BB%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>一段生产事故发人深省，在Spring的声明式事务中手动捕获异常，居然判定回滚了，这是什么操作？话不多说直接上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> C c;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b.insertB();</span><br><span class="line">            c.insertC();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BM bm;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bm.insert(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CM cm;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cm.insert(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h2><p>好了大家都看到上面这段代码了，在正常的情况的我们会往B表和C表中各插入一条数据，那么当代码出现异常时又会怎么样呢？</p><p>我们现在假设B插入数据成功，但是C插入数据失败了，此时异常会上抛到A，被A中<code>operate</code>方法的try - cache所捕获，正常来说此时数据库中B能插入一条记录，而C表插入失败，这是我们期望的情况，<font color="#cea5550">但事实却不是</font>，实际情况是B表没有插入数据，C表也没有插入数据，也就是说整个操作被Spring给回滚了</p><blockquote><p>注意点</p><p>如果代码稍稍变动一下，将try - cache放在<code>insertC</code>的代码块中，在同样的场景下，B中会成功插入一条记录</p></blockquote><h2 id="知识点前置条件"><a href="#知识点前置条件" class="headerlink" title="知识点前置条件"></a>知识点前置条件</h2><p>了解Spring的传播机制的可以直接跳过</p><blockquote><p>我们先要搞清楚Spring中的<code>REQUIRED</code>的作用</p><p>REQUIRED：如果当前没有事务就创建一个新的事务，如果当前已经存在事务就加入到当前事务</p><p>也就是说当我们的传播机制同时为<code>REQUIRED</code>时，A、B、C三者的事务是共用一个的，只有当A的流程全部走完时才会做一次commit或者rollback操作，不会在执行B或者C的过程中进行commit和rollback</p></blockquote><h2 id="问题追踪"><a href="#问题追踪" class="headerlink" title="问题追踪"></a>问题追踪</h2><p>好，有了一定的知识储备，我们一起来看源码</p><p>我们首先找到Spring事务的代理入口<code>TransactionInterceptor</code>, 当我们通过调用A类中的<code>operate</code>方法时会调用<code>TransactionInterceptor</code>的<code>invoke</code>方法，这是整个事务的入口，我们直接看重点<code>invoke</code>中的<code>invokeWithinTransaction</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取事务属性类 AnnotationTransactionAttributeSource</span></span><br><span class="line">TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line"><span class="comment">//获取事务属性</span></span><br><span class="line"><span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//获取事务管理器</span></span><br><span class="line"><span class="keyword">final</span> TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line"></span><br><span class="line">PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line"><span class="comment">//获取joinpoint</span></span><br><span class="line"><span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"><span class="comment">//注解事务会走这里</span></span><br><span class="line"><span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line"><span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">Object retVal;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line"><span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// target invocation exception</span></span><br><span class="line"><span class="comment">//事务回滚</span></span><br><span class="line">completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line"><span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">TransactionStatus status = txInfo.getTransactionStatus();</span><br><span class="line"><span class="keyword">if</span> (status != <span class="keyword">null</span> &amp;&amp; txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务提交</span></span><br><span class="line">commitTransactionAfterReturning(txInfo);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不重要的代码我已经省略了，好我们来看这个流程，上面这段代码很明显反应出了，当我们程序执行过程中抛出了异常时会调用到<code>completeTransactionAfterThrowing</code>的回滚操作，如果没有发生异常最终会调用事务提交<code>commitTransactionAfterReturning</code>， 我们来分析一下</p><p><img src="/blogs/img/transactionRequired.jpg" alt="img"></p><p>正常情况是C发生异常，并且执行到了<code>completeTransactionAfterThrowing</code>事务回滚，但是因为不是新创建的事务，而是加入的事务所以并不会触发回滚操作，而在A中捕获了该异常，并且最终走到<code>commitTransactionAfterReturning</code>事务提交，事实是这样的吗？</p><p>事实上就是这样的，那就奇怪了，我明明提交了，怎么反而回滚了，我们继续往下看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"><span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">TransactionDefinition def = (definition != <span class="keyword">null</span> ? definition : TransactionDefinition.withDefaults());</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点看.. DataSourceTransactionObject拿到对象</span></span><br><span class="line">Object transaction = doGetTransaction();</span><br><span class="line"><span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次进来connectionHolder为空的, 所以不存在事务</span></span><br><span class="line"><span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line"><span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line"><span class="comment">//如果不是第一次进来, 则会走这个逻辑</span></span><br><span class="line"><span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check definition settings for new transaction.</span></span><br><span class="line"><span class="keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">&quot;Invalid transaction timeout&quot;</span>, def.getTimeout());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span></span><br><span class="line"><span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line"><span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一次进来大部分会走这里（传播属性是 Required ｜ Requested New ｜ Nested）</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line"><span class="comment">//先挂起</span></span><br><span class="line">SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + def.getName() + <span class="string">&quot;]: &quot;</span> + def);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line"><span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line"><span class="keyword">if</span> (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line"><span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + def);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line"><span class="keyword">return</span> prepareTransactionStatus(def, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是开启事务的代码，我们来看，当我们A第一次走进来的时候，此时是没有事务的，所以<code>isExistingTransaction</code>方法不成立，往下走，因为我们的传播机制是REQUIRED，所以我们会走到<code>startTransaction</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">startTransaction</span><span class="params">(TransactionDefinition definition, Object transaction, <span class="keyword">boolean</span> debugEnabled, <span class="meta">@Nullable</span> SuspendedResourcesHolder suspendedResources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line"><span class="comment">//创建一个新的事务状态, 注意这里的newTransaction 属性为true</span></span><br><span class="line">DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">doBegin(transaction, definition);</span><br><span class="line"><span class="comment">//开启事务后, 改变事务状态</span></span><br><span class="line">prepareSynchronization(status, definition);</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好这里我们只需要关注一个点那就是<code>newTransactionStatus</code>的第三个参数<code>newTransaction</code>，只有当我们新创建一个事务的时候才会为<code>true</code>，<strong>这个属性很重要</strong>，我们后续还会用到它</p><p>好了，到这里第一次的事务开启就已经完成了，然后我们会调用业务逻辑，当调用insertB时，又会走到<code>getTransaction</code>，我们继续来看它，此时<code>isExistingTransaction</code>就可以拿到值了，因为A已经帮我们创建好了事务，此时会调用到<code>handleExistingTransaction</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果第二次进来还是PROPAFGATION_REQUIRED， 走这里, newTransation为false</span></span><br><span class="line"><span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>针对REQUIRED有用的代码就这一句，其他全部不用看，同样的我们看到第三个参数newTransaction，这里是false了，说明是加入了之前的事务，而不是自己新创建的，然后执行业务代码，最后走到commit，我们来看看commit中做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果有回滚点</span></span><br><span class="line"><span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Releasing transaction savepoint&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">status.releaseHeldSavepoint();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是新事务, 则提交事务</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Initiating transaction commit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">doCommit(status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它什么事情都没有做，为什么？因为我们的<code>newTransaction</code>不为true，所以当我们的代码在<code>operate</code>方法全部执行完以后才会走到这里</p><p>好接下来我们来看<code>insertC</code>，前面的流程都一模一样，我们直接看到回滚代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="keyword">boolean</span> unexpected)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> unexpectedRollback = unexpected;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">triggerBeforeCompletion(status);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Rolling back transaction to savepoint&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">status.rollbackToHeldSavepoint();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Initiating transaction rollback&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">doRollback(status);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Participating in larger transaction</span></span><br><span class="line"><span class="keyword">if</span> (status.hasTransaction()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">doSetRollbackOnly(status);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Should roll back transaction but cannot - no transaction available&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unexpected rollback only matters here if we&#x27;re asked to fail early</span></span><br><span class="line"><span class="keyword">if</span> (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Raise UnexpectedRollbackException if we had a global rollback-only marker</span></span><br><span class="line"><span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line"><span class="string">&quot;Transaction rolled back because it has been marked as rollback-only&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">cleanupAfterCompletion(status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的<code>insertC</code>方法同样它的newTransaction不是true，所以最终会走到<code>doSetRollbackOnly</code>，这个方法<strong>重中之重</strong>，最后会调用这样一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.rollbackOnly = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就要执行到我们的关键代码A中的<code>operate</code>的提交代码了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(<span class="string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line"><span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line"><span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Transactional code has requested rollback&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">processRollback(defStatus, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line"><span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">processRollback(defStatus, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行事务提交</span></span><br><span class="line">processCommit(defStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，看到这大家都明白了吧，在commit中，Spring会去判断<code>defStatus.isGlobalRollbackOnly</code>有没有抛出过异常被Spring所拦截，如果有，那么就不会执行commit操作，转而执行<code>processRollback</code>回滚操作</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><font color="#cea5550">在Spring的REQUIRED中，只要异常被Spring捕获到过，那么Spring最终就会回滚整个事务，即使自己在业务中已经捕获</font></p><p>所以我们回到最初的代码，如果我们希望Spring不进行回滚，那么我们只用将try-cache方法insertC方法中就可以，因为此时抛出的异常并不会被Spring所拦截到</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出Spring循环依赖</title>
      <link href="/blogs/2021/01/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BASpring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/blogs/2021/01/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BASpring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>相信做Java开发的同学都知道什么是Spring，并且一直都在使用它，但是面对我们老生常谈的话题Spring 的循环依赖，也有不少人知道，可是真的让你去详细的说明时，又显得一知半解说不清楚，不用急，我们现在就来揭开循环依赖的神秘面纱</p><h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h2><p>所谓的循环依赖指的就是类与类之间的依赖关系形成了闭环，就会导致循环依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceB serviceB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceA serviceA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这个例子就是一个典型的循环依赖，ServiceA的实例化需要依赖于ServiceB，而ServiceB又依赖于ServiceA，从而形成闭环</p><h2 id="几种循环依赖情况"><a href="#几种循环依赖情况" class="headerlink" title="几种循环依赖情况"></a>几种循环依赖情况</h2><p>在Spring中循环依赖主要有三种情况：</p><ul><li>基于构造器的方式进行依赖注入时产生的循环依赖</li><li>原型模式下Field的依赖注入</li><li>单例模式下Field的依赖注入</li></ul><blockquote><p>在Spring中只有第三种单例模式下的依赖注入是真正意义上的解决了循环依赖问题</p><p>如果硬要说其他的方式也能解决循环依赖，我不否认确实可以，我们来看下面这段代码（非本章讲解的重点，只是抛砖引玉，告诉大家循环依赖有多种处理方式）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceA</span><span class="params">(ServiceB serviceB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceB = serviceB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceB <span class="title">getServiceB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serviceB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceA serviceA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceB</span><span class="params">(ServiceA serviceA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceA = serviceA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceA <span class="title">getServiceA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serviceA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在任意一个构造函数上添加懒加载来解决循环依赖问题，运行结果如下：</p><p><img src="/blogs/img/loop1.jpg" alt="img"></p><h2 id="如何解决循环依赖"><a href="#如何解决循环依赖" class="headerlink" title="如何解决循环依赖"></a>如何解决循环依赖</h2><p>在Spring中解决循环依赖问题最主要的是通过后两层的缓存来处理</p><blockquote><p>先来看看Spring的缓存结构</p><ul><li>singletonObjects</li></ul><p>当Bean实例化结束以后才会放到当前缓存，随后的每次getBean操作都会调用到这里来获取Bean实例</p><ul><li>earlySingletonObjects</li></ul><p>只有正在创建中的Bean才会存在于当前缓存，解决第一个类引用替换为代理对象的场景</p><ul><li>singletonFactories</li></ul><p>提前存储暴露的实例的引用，从三级缓存中获取只会被调用一次，一旦获取到实例后就会添加到二级缓存</p></blockquote><h2 id="Spring调用流程"><a href="#Spring调用流程" class="headerlink" title="Spring调用流程"></a>Spring调用流程</h2><p>好了对循环依赖有了大致的概念以后，我们来看它是怎么处理的</p><ul><li><code>├─</code> getBean ① 实例化入口</li><li><code>│ ├─</code> doGetBean</li><li><code>│ │ ├─</code> getSingleton ② 查看缓存里是否有实例</li><li><code>│ │ ├─</code> getObjectForBeanInstance ③ 如果缓存有实例，直接返回实例</li><li><code>│ │ ├─</code> getSingletond ④ 缓存没有实例，创建实例</li><li><code>│ │ │ ├─</code> beforeSingletonCreation ⑤ 添加beanName到正在实例化的bean的set集合</li><li><code>│ │ │ ├─</code> createBean</li><li><code>│ │ │ │ ├─</code> doCreateBean ⑥ 执行创建实例</li><li><code>│ │ │ │ │ ├─</code> createBeanInstance ⑦ 创建实例过程</li><li><code>│ │ │ │ │ │ ├─</code> determineConstructorsFromBeanPostProcessors ⑧ 如果构造函数有@Autowired</li><li><code>│ │ │ │ │ │ │ ├─</code> autowireConstructor ⑨ 执行构造器实例过程不会走到步骤 ⑪</li><li><code>│ │ │ │ │ │ │ │ └─</code> getBean 返回 ① 实例化入口</li><li><code>│ │ │ │ │ ├─</code> applyMergedBeanDefinitionPostProcessors ⑩ 注解的搜集和装配过程</li><li><code>│ │ │ │ │ ├─</code> earlySingletonExposure ⑪ 暴露还没有完全实例化完成的 bean</li><li><code>│ │ │ │ │ ├─</code> addSingletonFactory ⑫ 将提前暴露的 bean，放到三级缓存</li><li><code>│ │ │ │ │ ├─</code> populateBean ⑬ 依赖注入</li><li><code>│ │ │ │ │ │ ├─</code> inject</li><li><code>│ │ │ │ │ │ │ ├─</code> AutowiredFieldElement.inject ⑭ 有@Autowired注解域的注入</li><li><code>│ │ │ │ │ │ │ │ └─</code> getBean 返回①实例化入口</li><li><code>│ │ │ │ │ │ │ ├─</code> AutowiredMethodElement.inject ⑭ 有@Autowired注解方法的注入</li><li><code>│ │ │ │ │ │ │ │ └─</code> getBean 返回①实例化入口</li><li><code>│ │ │ │ │ ├─</code> initializeBean ⑮ bean 实例化和IOC依赖注入完以后的增强处理过程</li><li><code>│ │ │ │ │ └─</code> registerDisposableBeanIfNecessary ⑮ bean 的销毁过程</li><li><code>│ │ │ ├─</code> afterSingletonCreation ⑯ 实例化完成，将beanName从正在实例化的bean的set集合中删除</li><li><code>│ │ │ └─</code> addSingleton ⑰ 创建完成后，将完全实例化后的bean 放到一级缓存</li></ul><p>好了，我们根据流程从上往下慢慢看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line"><span class="comment">//从一级缓存中获取单例对象</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="comment">//判断当前Bean是否正在创建中, 也就是没有初始化完成</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">//从二级缓存中获取单例对象</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="comment">//allowEarlyReference允许bean提前暴露</span></span><br><span class="line"><span class="comment">//是否允许从singleFactories中通过getObject拿到对象</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="comment">//从三级缓存中获取对象工厂</span></span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//通过单例工厂获取单例bean</span></span><br><span class="line"><span class="comment">//会调用到getEarlyBeanReference方法</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="comment">//从三级缓存移动到二级缓存</span></span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSingleton非常简单，依次从三级缓存中查找Bean的实例，一级缓存没有就从二级缓存找，二级缓存没有就从三级缓存找，这里我们第一次进来，所以无法获取到数据，接着往下看</p><p>中间的不重要的代码全部跳过，我们直接来看关键部分，看到这个方法<code>doCreateBean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (</span><br><span class="line">mbd.isSingleton() <span class="comment">//是否单例</span></span><br><span class="line">&amp;&amp; <span class="keyword">this</span>.allowCircularReferences <span class="comment">//是否允许提前暴露</span></span><br><span class="line">&amp;&amp; isSingletonCurrentlyInCreation(beanName) <span class="comment">//是否正在实例化</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加三级缓存</span></span><br><span class="line"><span class="comment">//从三级缓存中调用getObject方法时, 会调用getEarlyBeanReference</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码上下不重要的地方已经省略了，直接看这几行，首先它必须是一个单例模式初始化的Bean且允许提前暴露以及正在初始化，这个时候会将自己添加到三级缓存中，好我们看这个入参<code>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</code>,这个参数什么时候会调用到？</p><p>我们来理一遍流程 ServiceA初始化时会走到这里，接着往下依赖注入ServiceB，当ServiceB依赖注入A时，会在getSingleton中拿到三级缓存，而三级缓存则是调用<code>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</code>方法来获取ServiceA的实例</p><p>其实核心的代码块就这2段，接下来我们来看完整的流程图，完整的展示循环依赖的过程</p><p><img src="/blogs/img/loop2.jpg" alt="img"></p><p>至此大家对Spring 的循环依赖都有了一定了解了，那么我们继续往下走</p><h2 id="面试大拷问"><a href="#面试大拷问" class="headerlink" title="面试大拷问"></a>面试大拷问</h2><h3 id="1-二级缓存可不可以解决循环依赖问题"><a href="#1-二级缓存可不可以解决循环依赖问题" class="headerlink" title="1. 二级缓存可不可以解决循环依赖问题"></a>1. 二级缓存可不可以解决循环依赖问题</h3><p>首先对于这个问题，结论一定是否定的，否则Spring只用2级缓存就OK了，所以我们需要了解的是为什么二级缓存不行</p><p>好我们从两个方面来入手</p><ul><li>只采用一级缓存 和 二级缓存</li></ul><p>先来分析这种情况，首先我们要搞清楚，三级缓存中所存储的内容和二级缓存是不同的，二级缓存存的是Bean对象，而三级缓存则是一个工厂类，我们来看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段就是核心代码，什么时候会走到这里？当A注入B，然后B再循环注入A的时候，走到getSingleton方法，从三级缓存中获取Bean的时候就会走到这里，那么这段代码做了什么？给大家来个场景就懂了</p><p>现在我在某个方法上注入了@Transaction的注解，此时生成的Bean实际是个代理对象，而在循环依赖过程中同样的也应该要生成这样一个代理对象，那么如果说我的三级缓存中存的是一个对象那么B中所注入的对象就与实际的A对象不一致了，因为A最终应该生成的是一个代理对象</p><p>因此仅仅采用一级缓存 和 二级缓存 是无法满足循环依赖的</p><ul><li>只采用一级缓存 和 三级缓存</li></ul><p>我们再来看一级缓存和三级缓存的情况，既然有了上面的铺垫，那就很容易理解了，如果我有多层的依赖关系，每次循环依赖到A都要从三级缓存中去拿，那么就会产生 生成的是一个代理对象的代理对象，可能有点绕，我来个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Cacheable</span></span><br><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">b</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的@Cacheable会生成一次代理对象，在此基础之上@Transaction会再生成一层代理，所以，如果说只有使用三级缓存的话，就可能产生代理对象套代理对象的现象</p><h3 id="2-三级缓存的值是在什么时候填充的"><a href="#2-三级缓存的值是在什么时候填充的" class="headerlink" title="2. 三级缓存的值是在什么时候填充的"></a>2. 三级缓存的值是在什么时候填充的</h3><p>我们都知道获取三级缓存的地方是在getSingleton的时候，那么到底什么时候放的值</p><p>完整的代码在<code>AbstractAutowireCapableBeanFactory#doCreateBean</code>方法中，先说下这个方法干了什么事</p><ul><li>创建Bean实例</li><li>收集注解（@Autowired、@Value等）</li><li>Field填充</li><li>Aware、init-method等的调用</li><li>BeanPostProcessor的调用</li></ul><p>那么三级缓存的填充事发生在Bean的实例化以后，属性填充之前。</p><p>为什么是在这里进行填充，也很容易想明白，因为当进行属性填充的时候就会触发循环依赖，所以三级缓存的填充必须要在属性填充之前，而填充的值又必须已经存在，否则如何填充，因此又要在Bean的实例化之后</p><h3 id="3-如何知道当前Bean是否正在实例化"><a href="#3-如何知道当前Bean是否正在实例化" class="headerlink" title="3. 如何知道当前Bean是否正在实例化"></a>3. 如何知道当前Bean是否正在实例化</h3><p>Spring中会通过一个Set容器来把正在实例化的Bean的name放到容器中，触发时机是在第二次<code>getSingleton</code>的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeSingletonCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="keyword">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用<code>getSingleton</code>方法以后，调用<code>createBean</code>方法之前，会将BeanName放到Set（singletonsCurrentlyInCreation）容器中</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ol><li>Spring的循环依赖只能作用于单例模式下的基于setter注入的方式</li><li>三级缓存是为了解决AOP增强而产生的代理对象</li><li>二级缓存是为了解决三级缓存中AOP增强而导致的重复代理现象</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Configuration和Component的区别</title>
      <link href="/blogs/2021/01/09/Configuration%E5%92%8CComponent%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blogs/2021/01/09/Configuration%E5%92%8CComponent%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>@Configuration 和 @Component是我们常用的2个注解，当2个注解作用于Config上都能够完成注入功能，今天我们要讨论的就是这两者之间的区别</p><h2 id="注解差异"><a href="#注解差异" class="headerlink" title="注解差异"></a>注解差异</h2><p>我们先从注解本身来看两者的区别:</p><p>从代码上不难看出@Configuration的本质也是一个@Component，只是基于它作了一些扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line"><span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用差异"><a href="#应用差异" class="headerlink" title="应用差异"></a>应用差异</h2><p>光看注解我们并看不出有和区别，接下来我用2个例子来表述它们在应用过程中的具体差异</p><p>例1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Demo <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Demo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DemoFactory <span class="title">demoFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DemoFactory demoFactory= <span class="keyword">new</span> DemoFactory();</span><br><span class="line">demoFactory.setDemo(demo());</span><br><span class="line"><span class="keyword">return</span> demoFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个测试类来进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext applicationContext= <span class="keyword">new</span> AnnotationConfigApplicationContext(App.class);</span><br><span class="line">Demo demo= applicationContext.getBean(Demo.class);</span><br><span class="line">DemoFactory demoFactory= applicationContext.getBean(DemoFactory.class);</span><br><span class="line"></span><br><span class="line">System.out.println(demo.hashCode());</span><br><span class="line">System.out.println(demoFactory.getDemo().hashCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/blogs/img/configuration1.jpg" alt="img"><br>基于@Component注解的作用下 我们所拿到的值是不同的<br><img src="/blogs/img/configuration2.jpg" alt="img"><br>基于@Configuration注解的作用下 我们所拿到的值是相同的</p><p>同样的 我们再来看一段代码</p><p>例2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2Config</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Demo2 <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Demo2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DemoFactory <span class="title">demoFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DemoFactory demoFactory= <span class="keyword">new</span> DemoFactory();</span><br><span class="line">Demo2 demo2= demo2();</span><br><span class="line">demoFactory.setDemo3( (Demo3) demo2.getObject());</span><br><span class="line"><span class="keyword">return</span> demoFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Demo3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line"><span class="keyword">return</span> Demo3.class;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类我就省略了和上面的一样</p><p>结论也是一样的</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>通过这2个例子我们来思考2个问题</p><blockquote><ol><li>为什么Configuration要这样设计，为什么它返回的结果是对象本身而Component确实一个新的对象</li><li>Configuration是如何来实现这个功能的</li></ol></blockquote><h3 id="我们先来思考第一个问题"><a href="#我们先来思考第一个问题" class="headerlink" title="我们先来思考第一个问题"></a>我们先来思考第一个问题</h3><p>我们都知道在Spring中有一个非常重要的思想那就是单例，在正常情况下我们的项目使用的都是单例来完成的，如果说使用Component的方式来完成那就违背了这一准则，说白了在实例化的时候，我们从Factory中获取出来的对象 和 Spring管理的Bean并不是同一个对象可以吗？显然是否定的，拿一个例子来说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是Spring装配Redis模版的代码，如果说我们对Redis的信息在connectionFactory发生了变化那么基于Component的方式它是无法感知到的，因为它们共用的并不是一个实体，所以以单例的方式拿到一个共享对象是非常重要的</p><h3 id="我们再来看看第二个问题"><a href="#我们再来看看第二个问题" class="headerlink" title="我们再来看看第二个问题"></a>我们再来看看第二个问题</h3><p>那么Spring到底是如何实现的，其实大家都不需要去想就能直接了当的说出答案<strong>代理</strong>，为什么呢？很显然当我们的类试图去拿被@Bean所装饰的方法时，它会先从缓存中去获取对象，这不就是一个典型的<strong>代理模式</strong>吗</p><p>不信？让我们来看看源码</p><p>首先我们需要了解@Configuration的注解Spring是在哪里进行处理的，从名字就能看出来当然是<strong>ConfigurationClassPostProcessor</strong>，好我们看到处理的方法<code>postProcessBeanFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> factoryId = System.identityHashCode(beanFactory);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.factoriesPostProcessed.add(factoryId);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成代理对象</span></span><br><span class="line">enhanceConfigurationClasses(beanFactory);</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中有个非常醒目的方法<code>enhanceConfigurationClasses</code>，看名字就知道是cglib的动态代理</p><p>我们再来看看这个方法里面生成代理的类<strong>ConfigurationClassEnhancer</strong>，这个类中有个非常重要的方法<code>enhance</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, <span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line"><span class="keyword">if</span> (EnhancedConfiguration.class.isAssignableFrom(configClass)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(String.format(<span class="string">&quot;Ignoring request to enhance %s as it has &quot;</span> +</span><br><span class="line"><span class="string">&quot;already been enhanced. This usually indicates that more than one &quot;</span> +</span><br><span class="line"><span class="string">&quot;ConfigurationClassPostProcessor has been registered (e.g. via &quot;</span> +</span><br><span class="line"><span class="string">&quot;&lt;context:annotation-config&gt;). This is harmless, but you may &quot;</span> +</span><br><span class="line"><span class="string">&quot;want check your configuration and remove one CCPP if possible&quot;</span>,</span><br><span class="line">configClass.getName()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> configClass;</span><br><span class="line">&#125;</span><br><span class="line">Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(String.format(<span class="string">&quot;Successfully enhanced %s; enhanced class name is: %s&quot;</span>,</span><br><span class="line">configClass.getName(), enhancedClass.getName()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> enhancedClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Enhancer <span class="title">newEnhancer</span><span class="params">(Class&lt;?&gt; configSuperClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"><span class="comment">//需要增强的类，这边的configSuperClass实际上就是带有@Configuration注解的类</span></span><br><span class="line">enhancer.setSuperclass(configSuperClass);</span><br><span class="line">enhancer.setInterfaces(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;);</span><br><span class="line">enhancer.setUseFactory(<span class="keyword">false</span>);</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line"><span class="comment">//回调过滤器</span></span><br><span class="line">enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line"><span class="comment">//回调方法</span></span><br><span class="line">enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line"><span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是标准的cglib，对方法进行增强，这里补充一下Callback的回调方法总共有3个</p><ul><li>BeanMethodInterceptor</li></ul><p>对带有@Bean注解的方法的增强</p><ul><li>BeanFactoryAwareMethodInterceptor</li></ul><p>对实现了BeanFactoryAware接口的类中setBeanFactory方法的增强</p><ul><li>NoOp.INSTANCE</li></ul><p>不做任何处理</p><p>既然已经生成了代理，那么接下来就是在代理中作了哪些处理，让我们一起来看看<strong>BeanMethodInterceptor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有当@Bean的方法是被Spring调到的时候, 才会走下来</span></span><br><span class="line"><span class="keyword">if</span> (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled() &amp;&amp; BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) &#123;</span><br><span class="line">logger.info(String.format(<span class="string">&quot;@Bean method %s.%s is non-static and returns an object &quot;</span> +</span><br><span class="line"><span class="string">&quot;assignable to Spring&#x27;s BeanFactoryPostProcessor interface. This will &quot;</span> +</span><br><span class="line"><span class="string">&quot;result in a failure to process annotations such as @Autowired, &quot;</span> +</span><br><span class="line"><span class="string">&quot;@Resource and @PostConstruct within the method&#x27;s declaring &quot;</span> +</span><br><span class="line"><span class="string">&quot;@Configuration class. Add the &#x27;static&#x27; modifier to this method to avoid &quot;</span> +</span><br><span class="line"><span class="string">&quot;these container lifecycle issues; see @Bean javadoc for complete details.&quot;</span>,</span><br><span class="line">beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用被代理方法</span></span><br><span class="line"><span class="keyword">return</span> cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用代理对象手动调用@Bean的方法的时候才会走下来</span></span><br><span class="line"><span class="keyword">return</span> resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);</span><br></pre></td></tr></table></figure><p>这里需要注意的是，我上面写的例子最终是不会走到这个<strong>isCurrentlyInvokedFactoryMethod</strong>条件里面去的，<del>为什么我就先不扩展了，大家如果感兴趣可以去看SimpleInstantiationStrategy#instantiate，如果看不懂可以私聊我</del>，所以我们关注的是这个<strong>resolveBeanReference</strong>方法，这个方法中 关键代码就一句从beanFactory中获取Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName));</span><br></pre></td></tr></table></figure><p>那么这个时候去拿，拿到的就是同一个实例</p><h2 id="细节决定成败"><a href="#细节决定成败" class="headerlink" title="细节决定成败"></a>细节决定成败</h2><ol><li>为什么createClass返回的是类的反射对象而不是类的实例？</li></ol><p>大家着重看上面<strong>ConfigurationClassEnhancer</strong>中的这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));</span><br></pre></td></tr></table></figure><p><strong>因为这个类我们最终是需要交给Spring来进行管理，所以实例化的工作最终是交给Spring容器来做，而不是cglib来完成</strong></p><ol start="2"><li>isCurrentlyInvokedFactoryMethod(beanMethod)条件是怎么成立的？</li></ol><p>要搞清楚这个问题，我们首先要知道@Bean的对象是如何被Spring实例化的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果有FactoryMethodName属性 <span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment"> * 这个if成立条件只有2种情况:</span></span><br><span class="line"><span class="comment"> * 1. &lt;Bean&gt; 标签中配置了factory-method属性</span></span><br><span class="line"><span class="comment"> *  2. 方法上面加上了<span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 反射的方式调用FactoryMethod</span></span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Spring去实例化Bean的时候会去判断BeanDefinition是否包含FactoryMethod如果是，就会在容器<strong>currentlyInvokedFactoryMethod</strong>中添加</p><p>而<strong>isCurrentlyInvokedFactoryMethod</strong>就是判断容器中的方法是否与目前正在调用的方法一致</p><ol start="3"><li>Spring是如何知道哪些对象需要生成代理对象，哪些不需要？</li></ol><p>这个问题要从2部分出发<strong>判断</strong>、<strong>收集</strong></p><p>我们先来看判断需要生成代理的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.CONFIGURATION_CLASS_FULL.equals(configClassAttr)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Cannot enhance @Configuration bean definition &#x27;&quot;</span> +</span><br><span class="line">beanName + <span class="string">&quot;&#x27; since it is not stored in an AbstractBeanDefinition subclass&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (logger.isInfoEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Cannot enhance @Configuration bean definition &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; since its singleton instance has been created too early. The typical cause &quot;</span> +</span><br><span class="line"><span class="string">&quot;is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor &quot;</span> +</span><br><span class="line"><span class="string">&quot;return type: Consider declaring such methods as &#x27;static&#x27;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们回去判断标记是否为FULL，如果是就会装配进configBeanDefs，然后Spring就会循环configBeanDefs进行<code>enhance</code>增强</p><p>我们再来看Spring是在哪里打的标记（类的位置：ConfigurationClassPostProcessor#processConfigBeanDefinitions）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//获取所有的beanNames</span></span><br><span class="line">String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line"><span class="comment">//如果有该表示就不再处理</span></span><br><span class="line"><span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是候选的需要处理的BeanDefinition, 如果是则放入configCandidates容器中</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑在<strong>ConfigurationClassUtils.checkConfigurationClassCandidate</strong>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从metadata中获取Configuration注解</span></span><br><span class="line">Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration.class.getName());</span><br><span class="line"><span class="comment">//如果有Configuration注解, 就是full匹配标识</span></span><br><span class="line"><span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; !Boolean.FALSE.equals(config.get(<span class="string">&quot;proxyBeanMethods&quot;</span>))) &#123;</span><br><span class="line">beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是有Component、ComponentScan、Import、ImportResource或者方法上面有@Bean, 就是lite匹配</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (config != <span class="keyword">null</span> || isConfigurationCandidate(metadata)) &#123;</span><br><span class="line">beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有的带有Configuration注解的类打上FULL标记</p><blockquote><p>触发时机</p><p>在AbstractApplicationContext的refresh方法中的invokeBeanFactoryPostProcessors方法，它的触发时机是在BeanDefinition初始化结束以后实例化之前完成，这里会去循环调用实现了BeanDefinitionRegistryPostProcessor接口的类</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
